using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace ptr727.LanguageTags;

public partial class Rfc5646Data
{
    public const string DataUri =
        "https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry";
    public const string DataFileName = "rfc5646";

    public static Rfc5646Data LoadData(string fileName)
    {
        // File Format
        // https://www.rfc-editor.org/rfc/rfc5646#section-3.1

        // https://www.w3.org/International/articles/language-tags
        // https://datatracker.ietf.org/doc/html/draft-phillips-record-jar-02

        List<Record> recordList = [];
        Parser parser = new();
        using StreamReader lineReader = new(File.OpenRead(fileName));

        // First record is file date
        _ = parser.ReadAttributes(lineReader);
        DateOnly fileDate = parser.GetFileDate();

        // Read all record attributes separated by %% until EOF
        while (parser.ReadAttributes(lineReader))
        {
            recordList.Add(parser.GetRecord());
        }
        recordList.Add(parser.GetRecord());

        return new Rfc5646Data { FileDate = fileDate, RecordList = [.. recordList] };
    }

    public static Rfc5646Data LoadJson(string fileName) =>
        JsonSerializer.Deserialize<Rfc5646Data>(
            File.ReadAllText(fileName),
            JsonOptions.JsonReadOptions
        );

    public static void SaveJson(string fileName, Rfc5646Data rfc5646) =>
        File.WriteAllText(
            fileName,
            JsonSerializer.Serialize(rfc5646, JsonOptions.JsonWriteOptions)
        );

    public static void GenCode(string fileName, Rfc5646Data rfc5646)
    {
        StringBuilder stringBuilder = new();
        _ = stringBuilder
            .Append(
                CultureInfo.InvariantCulture,
                $$"""
                // This file is generated by LanguageTagsCreate

                using System;

                namespace ptr727.LanguageTags;

                public partial class Rfc5646Data
                {
                    public static Rfc5646Data Create() =>
                        new()
                        {
                            FileDate = new DateOnly({{rfc5646.FileDate.Year}}, {{rfc5646.FileDate.Month}}, {{rfc5646.FileDate.Day}}),
                            RecordList =
                            [
                """
            )
            .Append("\r\n");

        foreach (Record record in rfc5646.RecordList)
        {
            _ = stringBuilder
                .Append(
                    CultureInfo.InvariantCulture,
                    $$"""
                                    new()
                                    {
                                        Type = RecordType.{{record.Type.ToString()}},
                    """
                )
                .Append("\r\n");
            if (!string.IsNullOrEmpty(record.SubTag))
            {
                _ = stringBuilder
                    .Append(
                        CultureInfo.InvariantCulture,
                        $"                    SubTag = \"{record.SubTag}\","
                    )
                    .Append("\r\n");
            }
            if (record.Added != DateOnly.MinValue)
            {
                _ = stringBuilder
                    .Append(
                        CultureInfo.InvariantCulture,
                        $"                    Added = new DateOnly({record.Added.Year}, {record.Added.Month}, {record.Added.Day}),"
                    )
                    .Append("\r\n");
            }
            if (!string.IsNullOrEmpty(record.SuppressScript))
            {
                _ = stringBuilder
                    .Append(
                        CultureInfo.InvariantCulture,
                        $"                    SuppressScript = \"{record.SuppressScript}\","
                    )
                    .Append("\r\n");
            }
            if (record.Scope != RecordScope.None)
            {
                _ = stringBuilder
                    .Append(
                        CultureInfo.InvariantCulture,
                        $"                    Scope = RecordScope.{record.Scope.ToString()},"
                    )
                    .Append("\r\n");
            }
            if (!string.IsNullOrEmpty(record.MacroLanguage))
            {
                _ = stringBuilder
                    .Append(
                        CultureInfo.InvariantCulture,
                        $"                    MacroLanguage = \"{record.MacroLanguage}\","
                    )
                    .Append("\r\n");
            }
            if (record.Deprecated != DateOnly.MinValue)
            {
                _ = stringBuilder
                    .Append(
                        CultureInfo.InvariantCulture,
                        $"                    Deprecated = new DateOnly({record.Deprecated.Year}, {record.Deprecated.Month}, {record.Deprecated.Day}),"
                    )
                    .Append("\r\n");
            }
            if (!string.IsNullOrEmpty(record.PreferredValue))
            {
                _ = stringBuilder
                    .Append(
                        CultureInfo.InvariantCulture,
                        $"                    PreferredValue = \"{record.PreferredValue}\","
                    )
                    .Append("\r\n");
            }
            if (!string.IsNullOrEmpty(record.Tag))
            {
                _ = stringBuilder
                    .Append(
                        CultureInfo.InvariantCulture,
                        $"                    Tag = \"{record.Tag}\","
                    )
                    .Append("\r\n");
            }
            _ = stringBuilder
                .Append(
                    "                    Description = ["
                        + string.Join(
                            ", ",
                            record.Description.Select(item => $"@\"{item.Replace("\"", "\"\"")}\"")
                        )
                        + "],"
                )
                .Append("\r\n");
            _ = stringBuilder
                .Append(
                    "                    Comments = ["
                        + string.Join(
                            ", ",
                            record.Comments.Select(item => $"@\"{item.Replace("\"", "\"\"")}\"")
                        )
                        + "],"
                )
                .Append("\r\n");
            _ = stringBuilder
                .Append(
                    "                    Prefix = ["
                        + string.Join(
                            ", ",
                            record.Prefix.Select(item => $"@\"{item.Replace("\"", "\"\"")}\"")
                        )
                        + "],"
                )
                .Append("\r\n");
            _ = stringBuilder.Append("                },").Append("\r\n");
        }
        _ = stringBuilder
            .Append(
                """
                            ],
                        };
                }
                """
            )
            .Append("\r\n");

        Iso6392Data.WriteFile(fileName, stringBuilder.ToString());
    }

    private sealed class Parser
    {
        private readonly List<KeyValuePair<string, string>> _attributeList = [];

        public bool ReadAttributes(StreamReader lineReader)
        {
            // Read until %% or EOF
            _attributeList.Clear();
            bool eof = false;
            while (true)
            {
                // Read next line
                string line = lineReader.ReadLine();
                if (string.IsNullOrEmpty(line))
                {
                    // End of file
                    eof = true;
                    break;
                }
                if (line.Equals("%%", StringComparison.Ordinal))
                {
                    // End of record
                    break;
                }

                // First line should not be multiline
                Debug.Assert(!line.StartsWith("  ", StringComparison.Ordinal));

                // Multiline record starts with two spaces
                // Peek at the next line an look for a space
                while (true)
                {
                    // There is no PeekLine(), so we only get 1 char look ahead
                    // -1 is EOF or error, else cast to Char
                    int peek = lineReader.Peek();
                    if (peek == -1 || (char)peek != ' ')
                    {
                        // Done
                        break;
                    }

                    // Append the next line to the current line
                    string multiLine = lineReader.ReadLine();
                    Debug.Assert(multiLine.StartsWith("  ", StringComparison.Ordinal));
                    line = $"{line.Trim()} {multiLine.Trim()}";
                }

                // Create attribute pair
                int divider = line.IndexOf(':');
                string key = line[..divider];
                string value = line[(divider + 1)..].Trim();

                // Add to attribute list
                _attributeList.Add(new KeyValuePair<string, string>(key, value));
            }

            return !eof;
        }

        public Record GetRecord()
        {
            // Create a mutable tuple as placeholder
            (
                RecordType Type,
                string SubTag,
                List<string> Description,
                DateOnly Added,
                string SuppressScript,
                RecordScope Scope,
                string MacroLanguage,
                DateOnly Deprecated,
                List<string> Comments,
                List<string> Prefix,
                string PreferredValue,
                string Tag
            ) record = (
                Type: RecordType.None,
                SubTag: null,
                Description: [],
                Added: DateOnly.MinValue,
                SuppressScript: null,
                Scope: RecordScope.None,
                MacroLanguage: null,
                Deprecated: DateOnly.MinValue,
                Comments: [],
                Prefix: [],
                PreferredValue: null,
                Tag: null
            );

            Debug.Assert(_attributeList.Count > 0);
            foreach (KeyValuePair<string, string> pair in _attributeList)
            {
                switch (pair.Key.ToLowerInvariant())
                {
                    case "type":
                        record.Type = TypeFromString(pair.Value);
                        break;
                    case "subtag":
                        record.SubTag = pair.Value;
                        break;
                    case "description":
                        record.Description.Add(pair.Value);
                        break;
                    case "added":
                        record.Added = DateFromString(pair.Value);
                        break;
                    case "suppress-script":
                        record.SuppressScript = pair.Value;
                        break;
                    case "scope":
                        record.Scope = ScopeFromString(pair.Value);
                        break;
                    case "macrolanguage":
                        record.MacroLanguage = pair.Value;
                        break;
                    case "deprecated":
                        record.Deprecated = DateFromString(pair.Value);
                        break;
                    case "comments":
                        record.Comments.Add(pair.Value);
                        break;
                    case "prefix":
                        record.Prefix.Add(pair.Value);
                        break;
                    case "preferred-value":
                        record.PreferredValue = pair.Value;
                        break;
                    case "tag":
                        record.Tag = pair.Value;
                        break;
                    default:
                        throw new NotImplementedException();
                }
            }
            Debug.Assert(record.Type != RecordType.None);
            Debug.Assert(!string.IsNullOrEmpty(record.Tag) || !string.IsNullOrEmpty(record.SubTag));
            return new Record
            {
                Type = record.Type,
                SubTag = record.SubTag,
                Description = [.. record.Description],
                Added = record.Added,
                SuppressScript = record.SuppressScript,
                Scope = record.Scope,
                MacroLanguage = record.MacroLanguage,
                Deprecated = record.Deprecated,
                Comments = [.. record.Comments],
                Prefix = [.. record.Prefix],
                PreferredValue = record.PreferredValue,
                Tag = record.Tag,
            };
        }

        public DateOnly GetFileDate()
        {
            KeyValuePair<string, string> pair = _attributeList.First();
            Debug.Assert(pair.Key.Equals("File-Date", StringComparison.Ordinal));
            return DateFromString(pair.Value);
        }

        private static DateOnly DateFromString(string value) =>
            DateOnly.ParseExact(value, "yyyy-MM-dd", CultureInfo.InvariantCulture);
    }

    public enum RecordType
    {
        None,
        Language,
        ExtLanguage,
        Script,
        Variant,
        Grandfathered,
        Region,
        Redundant,
    }

    public enum RecordScope
    {
        None,
        MacroLanguage,
        Collection,
        Special,
        PrivateUse,
    }

    public record Record
    {
        [JsonConverter(typeof(JsonStringEnumConverter))]
        public RecordType Type { get; init; }
        public string SubTag { get; init; }
        public ImmutableArray<string> Description { get; init; }
        public DateOnly Added { get; init; }
        public string SuppressScript { get; init; }

        [JsonConverter(typeof(JsonStringEnumConverter))]
        public RecordScope Scope { get; init; }
        public string MacroLanguage { get; init; }
        public DateOnly Deprecated { get; init; }
        public ImmutableArray<string> Comments { get; init; }
        public ImmutableArray<string> Prefix { get; init; }
        public string PreferredValue { get; init; }
        public string Tag { get; init; }

        [JsonIgnore]
        public string TagAny => string.IsNullOrEmpty(SubTag) ? Tag : SubTag;
    }

    public DateOnly FileDate { get; init; }
    public ImmutableArray<Record> RecordList { get; init; }

    private static RecordType TypeFromString(string value) =>
        value.ToLowerInvariant() switch
        {
            "language" => RecordType.Language,
            "extlang" => RecordType.ExtLanguage,
            "script" => RecordType.Script,
            "variant" => RecordType.Variant,
            "grandfathered" => RecordType.Grandfathered,
            "region" => RecordType.Region,
            "redundant" => RecordType.Redundant,
            _ => throw new NotImplementedException(),
        };

    private static RecordScope ScopeFromString(string value) =>
        value.ToLowerInvariant() switch
        {
            "macrolanguage" => RecordScope.MacroLanguage,
            "collection" => RecordScope.Collection,
            "special" => RecordScope.Special,
            "private-use" => RecordScope.PrivateUse,
            _ => throw new NotImplementedException(),
        };

    public Record Find(string languageTag, bool includeDescription)
    {
        // Find the matching language entry
        Record record = null;

        // Tag
        record = RecordList.FirstOrDefault(item =>
            !string.IsNullOrEmpty(item.Tag)
            && item.Tag.Equals(languageTag, StringComparison.OrdinalIgnoreCase)
        );
        if (record != null)
        {
            return record;
        }

        // SubTag
        record = RecordList.FirstOrDefault(item =>
            !string.IsNullOrEmpty(item.SubTag)
            && item.SubTag.Equals(languageTag, StringComparison.OrdinalIgnoreCase)
        );
        if (record != null)
        {
            return record;
        }

        // PreferredValue
        record = RecordList.FirstOrDefault(item =>
            !string.IsNullOrEmpty(item.PreferredValue)
            && item.PreferredValue.Equals(languageTag, StringComparison.OrdinalIgnoreCase)
        );
        if (record != null)
        {
            return record;
        }

        // Description
        if (includeDescription)
        {
            // Exact match
            record = RecordList.FirstOrDefault(item =>
                item.Description.Any(description =>
                    description.Equals(languageTag, StringComparison.OrdinalIgnoreCase)
                )
            );
            if (record != null)
            {
                return record;
            }

            // Partial match
            record = RecordList.FirstOrDefault(item =>
                item.Description.Any(description =>
                    description.Contains(languageTag, StringComparison.OrdinalIgnoreCase)
                )
            );
            if (record != null)
            {
                return record;
            }
        }

        // Not found
        return null;
    }
}
